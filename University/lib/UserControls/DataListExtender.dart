import 'package:adaptive_scrollbar/adaptive_scrollbar.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter_pagewise/flutter_pagewise.dart';
import 'package:intl/intl.dart';
import 'package:linked_scroll_controller/linked_scroll_controller.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'EditText.dart';
import 'FlatEditText.dart';
import 'HoverExtender.dart';
import 'IconButtonExtender.dart';
import '../../Common/AppConfig.dart';
import '../Common/CommonMethod.dart';
import '../Common/GlobalStyle.dart';
import '../Common/LabelDictionary.dart';
import 'LabelText.dart';

//region Controller
enum DEColumnType {
  String,
  Numeric,
  DECheckbox,
  Widget,
  DEMoreMenu,
}

enum DENumericFormat {
  Date,
  Time,
  Time2,
  DateTime,
  Unit,
  Amount,
  Percent,
  Price,
  Quantity,
  Rate,
  Flag
}

class DEColumn{
  String columnName;
  DEColumnType columnType;
  DENumericFormat columnFormat;
  double columnWidth;
  TextAlign? columnAlign;
  TextStyle? headerStyle;
  Widget Function(int rowIndex, Map<String, dynamic> rowItem)? cellBuilder;
  Function(Map<String, dynamic> rowItem)? onSelected;
  String headerText;
  List<PopupMenuItem>? popupMenuItems;

  DEColumn({
    this.columnName = "",
    this.columnType = DEColumnType.String,
    this.columnFormat = DENumericFormat.Amount,
    this.columnWidth = 0,
    this.columnAlign = TextAlign.start,
    this.headerStyle,
    //this.columnChild,
    this.cellBuilder,
    //this.onChange,
    this.onSelected,
    this.headerText = "",
    this.popupMenuItems,
  });
}

class DEColumnStyle{
  final String columnName;
  final DEColumnType columnType;
  final DENumericFormat columnFormat;
  final double columnWidth;

  DEColumnStyle({
    this.columnName = "",
    this.columnType = DEColumnType.String,
    this.columnFormat = DENumericFormat.Amount,
    this.columnWidth = 0,
  });
}

class DataListExtenderController{
  bool isEnable = true;
  bool isVisible = true;
  bool isRefresh = false;
  bool isClear = false;
  List<Map<String, dynamic>> gridItem = [];
  List<Map<String, dynamic>> _gridShowItem = [];
  List<Map<String, dynamic>> _gridSelectedItem = [];
  List<int> hideColumns = [];

  List<Map<String, dynamic>> gridSelectedItem(){
    return _gridSelectedItem;
  }

  void cleanGridSelectedItem(){
    _gridSelectedItem = [];
  }

// void clear(){
//   _isClear = true;
// }
}
//endregion

//region Datagrid
class DataListExtender extends StatefulWidget {
  final Future<dynamic> Function(int intPageNumber, int intPageSize, String strSqlFilter, String strSqlSort) futureData;
  final List<DEColumn>? deColumns;
  final DataListExtenderController controller;
  final double? width;
  final double? height;
  final Function(Map<String, dynamic> rowItem)? onSelectedRow;
  final bool autoGeneratedColumns;
  final bool showPaging;
  final List<int>? hideColumns;
  final List<DEColumn>? Function(List<DEColumn> lstGeneratedColumn, List<String> lstColumnName)? onGenerateColumn;
  final Function()? onAddLine;
  final Function()? onDeleteLine;
  final Function()? onBeforeRefresh;
  final Function()? onAfterRefresh;
  final List<PopupMenuItem>? popupMenuItems;
  final Widget? Function(BuildContext context)? filterBuilder;
  final String? title;
  final bool isAdvanceFilterVisible;
  final bool isAddLineVisible;
  final bool isDeleteLineVisible;
  final bool isMoreMenuVisible;
  final bool isFilterVisible;
  final bool isFilterContentVisible;
  final bool isRefreshVisible;
  final bool isRefreshEnable;
  final bool isAdvanceFilterEnable;
  final bool isAddLineEnable;
  final bool isDeleteLineEnable;
  final bool isFilterEnable;
  final String addLineLabel;
  final String deleteLineLabel;
  final int? pageSize;
  final bool isRefreshOnFilter;
  final List<DEColumnStyle>? autoGeneratedColumnStyle;
  final bool? isSubTotalVisible;
  final bool isListView;
  final Function(Map<String, dynamic> rowItem)? listViewItemBuilder;

  const DataListExtender({
    super.key,
    required this.futureData,
    this.deColumns,
    required this.controller,
    this.width,
    this.height,
    this.onSelectedRow,
    this.autoGeneratedColumns = false,
    this.showPaging = true,
    this.hideColumns,
    this.onGenerateColumn,
    this.onAddLine,
    this.onDeleteLine,
    this.onBeforeRefresh,
    this.onAfterRefresh,
    this.popupMenuItems,
    this.filterBuilder,
    this.title,
    this.isAdvanceFilterVisible = false,
    this.isAddLineVisible = false,
    this.isDeleteLineVisible = false,
    this.isMoreMenuVisible = false,
    this.isFilterVisible = true,
    this.isAdvanceFilterEnable = true,
    this.isRefreshVisible = true,
    this.isRefreshEnable = true,
    this.isFilterEnable = true,
    this.isFilterContentVisible = false,
    this.isAddLineEnable = true,
    this.isDeleteLineEnable = true,
    this.addLineLabel = "Add",
    this.deleteLineLabel = "Delete",
    this.pageSize,
    this.isRefreshOnFilter = false,
    this.autoGeneratedColumnStyle,
    this.isSubTotalVisible,
    this.isListView = false,
    this.listViewItemBuilder,
  });

  @override
  createState() => DataListExtenderState();
}

class DataListExtenderState<T> extends State<DataListExtender> {
  bool isFirstLoad = true;

  Widget? widgetDEBody;
  int pageNum = 1;
  int pageSize = 0;
  int totalPage = 0;
  int totalRecord = 0;
  Map<int, double> mapColWidth = {};
  Map<String, dynamic> numericColumns = {};
  Map<String, dynamic> hoverColumns = {};
  List<DEColumn> lstDEColumn = [];
  List<String> lstDecimalColumn = [];
  Map<String, dynamic> numericColumnSums = {};

  double gridWidth = 1200;

  late LinkedScrollControllerGroup horizontalGroupScrollController;

  late ScrollController horizontalHeaderScrollController;
  late ScrollController horizontalBodyScrollController;
  late ScrollController horizontalFilterScrollController;
  late ScrollController verticalBodyScrollController;
  late ScrollController horizontalSubTotalScrollController;

  final ScrollController verticalAdvancedFilterScrollController = ScrollController();

  final EditTextController edtPage = EditTextController();
  final EditTextController edtPageSize = EditTextController();

  bool isContentVisible = true;
  bool isAdvanceFilterContentVisible = false;
  bool isFilterContentVisible = false;
  bool isEnableGridScroll = true;
  bool checkboxHeaderValue = false;
  bool isFilterTriggerRefresh = false;

  final OverlayPortalController overlayFilterController = OverlayPortalController();

  Map<String, FlatEditTextController> lstSearchController = {};

  String strSortBy = "";
  String strSortDirection = "A";

  late PagewiseLoadController pageLoadController;

  //region Init
  @override
  void initState() {
    widget.controller.hideColumns = widget.hideColumns ?? [];
    pageSize = widget.pageSize ?? AppConfig.PageSize;

    //gridWidth = widget.width ?? MediaQuery.of(context).size.width - 100;

    horizontalGroupScrollController = LinkedScrollControllerGroup();
    horizontalHeaderScrollController = horizontalGroupScrollController.addAndGet();
    horizontalBodyScrollController = horizontalGroupScrollController.addAndGet();
    horizontalFilterScrollController = horizontalGroupScrollController.addAndGet();
    horizontalSubTotalScrollController = horizontalGroupScrollController.addAndGet();

    verticalBodyScrollController = ScrollController();
    isFilterContentVisible = widget.isFilterContentVisible;

    isEnableGridScroll = (widget.height ?? 0) > 50 ? true : false;
    // debugPrint("Init - set isEnableGridScroll ${isEnableGridScroll.toString()}");

    pageLoadController = PagewiseLoadController(
      pageSize: AppConfig.PageSize,
      pageFuture: (pageIndex) {
        pageNum = (pageIndex ?? 0) + 1;
        return _getList();
      },
    );

    super.initState();

    WidgetsBinding.instance.addPostFrameCallback((timeStamp) async {
      SharedPreferences prefs = await SharedPreferences.getInstance();
      bool isAppInitRun = prefs.getBool("isAppInitRun") ?? true;

      // debugPrint("[DatagridExtender] isAppInitRun: ${isAppInitRun.toString()}");
      var futureWithTheLoop = () async {
        while(isAppInitRun){
          isAppInitRun = prefs.getBool("isAppInitRun") ?? true;
          // debugPrint("[DatagridExtender] isAppInitRun: ${isAppInitRun.toString()}");
          await Future.delayed(const Duration(milliseconds: 10));
        }
      }();

      Future.wait([futureWithTheLoop]).whenComplete((){
        if(!isAppInitRun) {
          isFirstLoad = true;

          if(widget.isListView){
            pageLoadController.reset();
          }
        }
      });
    });
  }
  //endregion

  //region Methods
  Future<List<Map<String, dynamic>>> _getList() async {
    List<Map<String, dynamic>>? lstData;

    List<String> lstSearchKey = [];
    List<String> lstSearchBy = [];

    String strSqlFilter = "";
    String strSqlSortBy = "";
    bool isRefreshData = false;

    debugPrint("_getList");
    debugPrint("isRefresh ${widget.controller.isRefresh}");
    debugPrint("isRefreshOnFilter ${widget.isRefreshOnFilter}");
    debugPrint("isFilterTriggerRefresh $isFilterTriggerRefresh");
    debugPrint("lstSearchController.length ${lstSearchController.length.toString()}");
    debugPrint("gridSelectedItem.length ${widget.controller._gridSelectedItem.length.toString()}");

    debugPrint("isFirstLoad $isFirstLoad");
    debugPrint("PageNum $pageNum");
    debugPrint("PageSize $pageSize");

    isRefreshData = widget.controller.isRefresh;

    if(isFirstLoad) {
      isFirstLoad = false;
    }

    if (lstSearchController.isNotEmpty) {
      debugPrint("_getList - create filter");

      for (int n = 0; n < lstSearchController.keys.length; n++) {
        lstSearchBy.add(lstSearchController.keys.elementAt(n));
        FlatEditTextController? flatText = lstSearchController[lstSearchController
            .keys.elementAt(n)];
        if (flatText != null) {
          lstSearchKey.add(flatText.text);
        }
      }
    }

    if (lstSearchBy.isNotEmpty && lstSearchKey.isNotEmpty && widget.isRefreshOnFilter) {
      for (int s = 0; s < lstSearchKey.length; s++) {
        if(lstSearchKey[s].isNotEmpty){
          if(strSqlFilter.isNotEmpty){
            strSqlFilter += " AND ";
          }
          strSqlFilter += "${lstSearchBy[s]} LIKE '%${lstSearchKey[s]}%'";
        }
      }
      // debugPrint(strSqlFilter);
    }

    if (strSortBy.isNotEmpty && widget.isRefreshOnFilter) {
      strSqlSortBy = "$strSortBy ${strSortDirection == "A"
          ? "ASC"
          : "DESC"}";
    }

    if(!isRefreshData){
      if(widget.isRefreshOnFilter && strSqlFilter.isNotEmpty && isFilterTriggerRefresh){
        isRefreshData = true;
        isFilterTriggerRefresh = false;
      }
    }

    if(isRefreshData){
      if (!widget.autoGeneratedColumns) {
        if(widget.controller.isClear == true){
          lstDEColumn.clear();
          widget.controller.isClear = false;
        }
        lstDEColumn = widget.deColumns!;
      }

      debugPrint("getFutureData");
      List lstT = await widget.futureData(pageNum, pageSize, strSqlFilter, strSqlSortBy) as List;
      // debugPrint("getFutureData - finish");

      if(lstT.isNotEmpty){
        lstData = [];
        if(lstT[0] is Map<String, dynamic>){
          for(int r = 0; r < lstT.length; r++){
            Map<String, dynamic> map = lstT[r];
            lstData.add(map);
          }
        }else{
          lstData = lstT.map((e) => e.toMap()).cast<Map<String, dynamic>>().toList();
        }
      }

      if(lstData != null){
        for(int r = 0; r < lstData.length; r++){
          Map<String, dynamic> mapRow = lstData[r];
          if (!mapRow.containsKey("IsSelected")) {
            mapRow["IsSelected"] = false;
          }

          if(_selectedItemExists(mapRow) > -1){
            mapRow["IsSelected"] = true;
          }

          lstData[r] = mapRow;
        }
      }

      widget.controller.gridItem = lstData ?? [];
    }else{
      lstData = widget.controller.gridItem;
    }

    // debugPrint("_getList - filter");
    if (lstSearchController.isNotEmpty) {
      // debugPrint(lstSearchKey.join("|"));
      if (lstSearchBy.isNotEmpty && lstSearchKey.isNotEmpty && !widget.isRefreshOnFilter) {
        for (int s = 0; s < lstSearchKey.length; s++) {
          if (lstData != null &&
              lstData.isNotEmpty &&
              lstSearchKey[s].isNotEmpty) {
            lstData = lstData.where((e) {
              // debugPrint("${e[lstSearchBy[s]].toString().toLowerCase()} is contain ${lstSearchKey[s]}");
              return e[lstSearchBy[s]]
                  .toString()
                  .toLowerCase()
                  .contains(lstSearchKey[s].toLowerCase());
            }).toList();
          }
        }
      }

      // debugPrint("_getList - sort");
      if (lstSearchBy.isNotEmpty && strSortBy.isNotEmpty && !widget.isRefreshOnFilter) {
        //debugPrint("$strSortBy $strSortDirection");
        lstData!.sort(
              (a, b) {
            if (strSortDirection == "A") {
              return a[strSortBy]
                  .toString()
                  .toLowerCase()
                  .compareTo(b[strSortBy].toString().toLowerCase());
            } else {
              return b[strSortBy]
                  .toString()
                  .toLowerCase()
                  .compareTo(a[strSortBy].toString().toLowerCase());
            }
          },
        );
      }
    }

    // if(widget.controller._isClear){
    //   widget.controller._isClear = false;
    //   lstData = [];
    // }

    // debugPrint("_getList - finish");

    if(widget.controller.isRefresh){
      widget.controller.isRefresh = false;

      // debugPrint("_getList - lstSearchController.clear()");
      // lstSearchController.clear();
    }

    // if(isRefreshData) {
    //   if (!widget.autoGeneratedColumns) {
    //     if (widget.controller.isClear == true) {
    //       lstDEColumn.clear();
    //       widget.controller.isClear = false;
    //     }
    //     lstDEColumn = widget.deColumns!;
    //   }
    // }

    if(lstData != null){
      for(int r = 0; r < lstData.length; r++){
        Map<String, dynamic> mapRow = lstData[r];
        if (!mapRow.containsKey("IsSelected")) {
          mapRow["IsSelected"] = false;
          lstData[r] = mapRow;
        }
      }
    }

    widget.controller._gridShowItem = lstData ?? [];
    // debugPrint(lstData.toString());
    return Future.value(lstData);
  }

  void _generateColumnProperty(List<DEColumn> lstDEColumn){
    // numericColumns.clear();
    // hoverColumns.clear();
    // mapColWidth.clear();
    // lstSearchController = {};

    // if (numericColumns.length != lstDEColumn.length) {
    //   numericColumns.clear();
    // }
    //
    // if (hoverColumns.length != lstDEColumn.length) {
    //   hoverColumns.clear();
    // }

    // if (mapColWidth.length != lstDEColumn.length) {
    //   mapColWidth.clear();
    // }

    if (lstDEColumn.isNotEmpty) {
      double totalColWidth = 0;

      for (int h = 0; h < lstDEColumn.length; h++) {
        DEColumn objHeader = lstDEColumn[h];
        // debugPrint("Generate ColumnProperty ${objHeader.columnName}");

        // debugPrint("add lstSearchController ");
        if(!lstSearchController.containsKey(objHeader.columnName)){
          lstSearchController[objHeader.columnName] = FlatEditTextController();
        }

        // debugPrint("add numericColumns");
        if(!numericColumns.containsKey(objHeader.columnName)) {
          bool isNum = false;
          if (objHeader.columnType == DEColumnType.Numeric) {
            isNum = true;

            if (objHeader.columnFormat == DENumericFormat.Date
                || objHeader.columnFormat == DENumericFormat.Time
                || objHeader.columnFormat == DENumericFormat.Time2
                || objHeader.columnFormat == DENumericFormat.DateTime
                || objHeader.columnFormat == DENumericFormat.Flag
            ) {
              isNum = false;
            }
          }

          numericColumns[objHeader.columnName] = isNum;
        }

        // debugPrint("add hoverColumns");
        if(!hoverColumns.containsKey(objHeader.columnName)) {
          hoverColumns[objHeader.columnName] = false;
        }


        // debugPrint("add mapColWidth");
        if (objHeader.columnType == DEColumnType.DECheckbox) {
          mapColWidth[h] = 30;
        } else if (objHeader.columnType == DEColumnType.DEMoreMenu) {
          mapColWidth[h] = 30;
        } else {
          if (objHeader.columnWidth > 0) {
            mapColWidth[h] = objHeader.columnWidth;
          } else {
            mapColWidth[h] = -1;
          }
        }

        if (mapColWidth[h] != -1) {
          totalColWidth += mapColWidth[h] ?? 0;
        }
      }

      if (isEnableGridScroll && mapColWidth.containsValue(-1)) {
        // debugPrint("calculate mapColWidth -1");
        for (int c = 0; c < mapColWidth.length; c++) {
          if (mapColWidth[c] == -1) {
            mapColWidth[c] = gridWidth - totalColWidth;
          }
        }
      }

    }
  }

  void _saveSelectedItem(Map<String, dynamic> mapRowSelectedItem, bool chbValue){
    Map<String, dynamic> mapCompare = {...mapRowSelectedItem};
    mapCompare["IsSelected"] = true;

    if(widget.controller._gridSelectedItem.isNotEmpty){
      int intSelectedItem = _selectedItemExists(mapCompare);
      bool isSelectedItemExists = intSelectedItem > -1;

      if(isSelectedItemExists){
        //NotEmpty-Exists-False
        if(!chbValue){
          widget.controller._gridSelectedItem.removeAt(intSelectedItem);
        }
      }
      else{
        //NotEmpty-NotExists-True
        if(chbValue){
          widget.controller._gridSelectedItem.add(mapCompare);
        }
      }
    }else{
      //Empty-True
      if(chbValue){
        widget.controller._gridSelectedItem.add(mapCompare);
      }
    }
  }

  int _selectedItemExists(Map<String, dynamic> mapRowSelectedItem){
    Map<String, dynamic> mapCompare = {...mapRowSelectedItem};
    mapCompare["IsSelected"] = true;
    int intSelectedItem = -1;

    if(widget.controller._gridSelectedItem.isNotEmpty){
      for(int c = 0; c < widget.controller._gridSelectedItem.length; c++){
        if(mapEquals(widget.controller._gridSelectedItem.elementAt(c), mapCompare)){
          intSelectedItem = c;
          break;
        }
      }
    }

    return intSelectedItem;
  }
  //endregion

  @override
  Widget build(BuildContext context) {
    //debugPrint("gridWidth: " + gridWidth.toString());


    return LayoutBuilder(
      builder: (context, constraint) {
        // double columnWidth = 0;
        // for(int h = 0; h < lstDEColumn.length; h++){
        //   DEColumn objHeader = lstDEColumn[h];
        //   if(objHeader.columnWidth > 0){
        //     columnWidth += objHeader.columnWidth;
        //   }else{
        //     if(objHeader.columnType != DEColumnType.DECheckbox) {
        //       columnWidth = 0;
        //       break;
        //     }
        //   }
        // }

        gridWidth = widget.width ?? MediaQuery.of(context).size.width - 80;

        //double gridWidth = context.size!.width;
        // if(columnWidth > 0){
        //   gridWidth = columnWidth;
        // }

        // debugPrint("gridWidth ${gridWidth.toString()}");

        return SizedBox(
          width: gridWidth,
          height: widget.height,
          child: widgetDEListRow(),
        );
      },
    );
  }

  Widget widgetDEListRow(){
    return RefreshIndicator(
      onRefresh: () async {
        pageLoadController.reset();
        await Future.value({});
      },
      child: PagewiseListView(
        pageLoadController: pageLoadController,
        itemBuilder: (context, entry, index) {
          SchedulerBinding.instance.addPostFrameCallback((_) async {
            await Future.delayed(const Duration(milliseconds: 500));

            if(widget.onAfterRefresh != null){
              widget.onAfterRefresh!();
            }
          });

          Map<String, dynamic> rowItem = entry as Map<String, dynamic>;


          Widget lvi;

          if(widget.listViewItemBuilder != null) {
            lvi = widget.listViewItemBuilder!(rowItem);
          }else{
            List<Widget> lstRowContent = [];
            for(int a = 0; a < rowItem.length; a++){
              lstRowContent.add(widgetDEListItem(rowItem, a));
            }

            lvi = Column(
              children: lstRowContent,
            );
          }


          return Container(
            padding: const EdgeInsets.only(top: 10, left: 0, right: 0, bottom: 6),
            child: InkWell(
                onTap: () {
                  if(widget.onSelectedRow != null) {
                    widget.onSelectedRow!(rowItem);
                  }
                },
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.start,
                  mainAxisSize: MainAxisSize.max,
                  children: <Widget>[
                    Container(
                      decoration: BoxDecoration(
                        color: GlobalStyle.listItemColor,
                        border: Border.all(color: Colors.grey, width: 0.5),
                        borderRadius: BorderRadius.circular(5),
                      ),
                      padding: const EdgeInsets.all(10),
                      width: gridWidth,
                      child: lvi,
                    ),
                  ],
                )),
          );
        },
      ),
    );
  }

  Widget widgetDEListItem(Map<String, dynamic> rowItem, int index){
    return Row(
      children: [
        LabelText(labelText: rowItem.keys.elementAt(index), labelColor: GlobalStyle.listItemTextColor,),
        LabelText(labelText: rowItem.values.elementAt(index), labelColor: GlobalStyle.listItemTextColor,),
      ],
    );
  }
}
//endregion
