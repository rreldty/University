import 'package:adaptive_scrollbar/adaptive_scrollbar.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter_pagewise/flutter_pagewise.dart';
import 'package:intl/intl.dart';
import 'package:linked_scroll_controller/linked_scroll_controller.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'EditText.dart';
import 'FlatEditText.dart';
import 'HoverExtender.dart';
import 'IconButtonExtender.dart';
import '../../Common/AppConfig.dart';
import '../Common/CommonMethod.dart';
import '../Common/GlobalStyle.dart';
import '../Common/LabelDictionary.dart';
import 'LabelText.dart';

//region Controller
enum DEColumnType {
  String,
  Numeric,
  DECheckbox,
  Widget,
  DEMoreMenu,
}

enum DENumericFormat {
  Date,
  Time,
  Time2,
  DateTime,
  Unit,
  Amount,
  Percent,
  Price,
  Quantity,
  Rate,
  Flag
}

class DEColumn {
  String columnName;
  DEColumnType columnType;
  DENumericFormat columnFormat;
  double columnWidth;
  TextAlign? columnAlign;
  TextStyle? headerStyle;
  Widget Function(int rowIndex, Map<String, dynamic> rowItem)? cellBuilder;
  Function(Map<String, dynamic> rowItem)? onSelected;
  String headerText;
  List<PopupMenuItem>? popupMenuItems;

  DEColumn({
    this.columnName = "",
    this.columnType = DEColumnType.String,
    this.columnFormat = DENumericFormat.Amount,
    this.columnWidth = 0,
    this.columnAlign = TextAlign.start,
    this.headerStyle,
    //this.columnChild,
    this.cellBuilder,
    //this.onChange,
    this.onSelected,
    this.headerText = "",
    this.popupMenuItems,
  });
}

class DEColumnStyle {
  final String columnName;
  final DEColumnType columnType;
  final DENumericFormat columnFormat;
  final double columnWidth;

  DEColumnStyle({
    this.columnName = "",
    this.columnType = DEColumnType.String,
    this.columnFormat = DENumericFormat.Amount,
    this.columnWidth = 0,
  });
}

class DataGridExtenderController {
  bool isEnable = true;
  bool isVisible = true;
  bool isRefresh = false;
  bool isClear = false;
  List<Map<String, dynamic>> gridItem = [];
  List<Map<String, dynamic>> _gridShowItem = [];
  List<Map<String, dynamic>> _gridSelectedItem = [];
  List<int> hideColumns = [];

  List<Map<String, dynamic>> gridSelectedItem() {
    return _gridSelectedItem;
  }

  void cleanGridSelectedItem() {
    _gridSelectedItem = [];
  }

// void clear(){
//   _isClear = true;
// }
}
//endregion

//region Datagrid
class DataGridExtender extends StatefulWidget {
  final Future<dynamic> Function(int intPageNumber, int intPageSize,
      String strSqlFilter, String strSqlSort) futureData;
  final List<DEColumn>? deColumns;
  final DataGridExtenderController controller;
  final double? width;
  final double? height;
  final Function(Map<String, dynamic> rowItem)? onSelectedRow;
  final bool autoGeneratedColumns;
  final bool showPaging;
  final List<int>? hideColumns;
  final List<DEColumn>? Function(
          List<DEColumn> lstGeneratedColumn, List<String> lstColumnName)?
      onGenerateColumn;
  final Function()? onAddLine;
  final Function()? onDeleteLine;
  final Function()? onBeforeRefresh;
  final Function()? onAfterRefresh;
  final List<PopupMenuItem>? popupMenuItems;
  final Widget? Function(BuildContext context)? filterBuilder;
  final String? title;
  final bool isAdvanceFilterVisible;
  final bool isAddLineVisible;
  final bool isDeleteLineVisible;
  final bool isMoreMenuVisible;
  final bool isFilterVisible;
  final bool isFilterContentVisible;
  final bool isRefreshVisible;
  final bool isRefreshEnable;
  final bool isAdvanceFilterEnable;
  final bool isAddLineEnable;
  final bool isDeleteLineEnable;
  final bool isFilterEnable;
  final String addLineLabel;
  final String deleteLineLabel;
  final int? pageSize;
  final bool isRefreshOnFilter;
  final List<DEColumnStyle>? autoGeneratedColumnStyle;
  final bool? isSubTotalVisible;

  const DataGridExtender(
      {super.key,
      required this.futureData,
      this.deColumns,
      required this.controller,
      this.width,
      this.height,
      this.onSelectedRow,
      this.autoGeneratedColumns = false,
      this.showPaging = true,
      this.hideColumns,
      this.onGenerateColumn,
      this.onAddLine,
      this.onDeleteLine,
      this.onBeforeRefresh,
      this.onAfterRefresh,
      this.popupMenuItems,
      this.filterBuilder,
      this.title,
      this.isAdvanceFilterVisible = false,
      this.isAddLineVisible = false,
      this.isDeleteLineVisible = false,
      this.isMoreMenuVisible = false,
      this.isFilterVisible = true,
      this.isAdvanceFilterEnable = true,
      this.isRefreshVisible = true,
      this.isRefreshEnable = true,
      this.isFilterEnable = true,
      this.isFilterContentVisible = false,
      this.isAddLineEnable = true,
      this.isDeleteLineEnable = true,
      this.addLineLabel = "Add",
      this.deleteLineLabel = "Delete",
      this.pageSize,
      this.isRefreshOnFilter = false,
      this.autoGeneratedColumnStyle,
      this.isSubTotalVisible});

  @override
  createState() => DataGridExtenderState();
}

class DataGridExtenderState<T> extends State<DataGridExtender> {
  bool isFirstLoad = true;

  Widget? widgetDEBody;
  int pageNum = 1;
  int pageSize = 0;
  int totalPage = 0;
  int totalRecord = 0;
  Map<int, double> mapColWidth = {};
  Map<String, dynamic> numericColumns = {};
  Map<String, dynamic> hoverColumns = {};
  List<DEColumn> lstDEColumn = [];
  List<String> lstDecimalColumn = [];
  Map<String, dynamic> numericColumnSums = {};

  double gridWidth = 1200;

  late LinkedScrollControllerGroup horizontalGroupScrollController;

  late ScrollController horizontalHeaderScrollController;
  late ScrollController horizontalBodyScrollController;
  late ScrollController horizontalFilterScrollController;
  late ScrollController verticalBodyScrollController;
  late ScrollController horizontalSubTotalScrollController;

  final ScrollController verticalAdvancedFilterScrollController =
      ScrollController();

  final EditTextController edtPage = EditTextController();
  final EditTextController edtPageSize = EditTextController();

  bool isContentVisible = true;
  bool isAdvanceFilterContentVisible = false;
  bool isFilterContentVisible = false;
  bool isEnableGridScroll = true;
  bool checkboxHeaderValue = false;
  bool isFilterTriggerRefresh = false;

  final OverlayPortalController overlayFilterController =
      OverlayPortalController();

  Map<String, FlatEditTextController> lstSearchController = {};

  String strSortBy = "";
  String strSortDirection = "A";

  late PagewiseLoadController pageLoadController;

  //region Init
  @override
  void initState() {
    widget.controller.hideColumns = widget.hideColumns ?? [];
    pageSize = widget.pageSize ?? AppConfig.PageSize;

    //gridWidth = widget.width ?? MediaQuery.of(context).size.width - 100;

    horizontalGroupScrollController = LinkedScrollControllerGroup();
    horizontalHeaderScrollController =
        horizontalGroupScrollController.addAndGet();
    horizontalBodyScrollController =
        horizontalGroupScrollController.addAndGet();
    horizontalFilterScrollController =
        horizontalGroupScrollController.addAndGet();
    horizontalSubTotalScrollController =
        horizontalGroupScrollController.addAndGet();

    verticalBodyScrollController = ScrollController();
    isFilterContentVisible = widget.isFilterContentVisible;

    isEnableGridScroll = (widget.height ?? 0) > 50 ? true : false;
    // debugPrint("Init - set isEnableGridScroll ${isEnableGridScroll.toString()}");

    pageLoadController = PagewiseLoadController(
      pageSize: AppConfig.PageSize,
      pageFuture: (pageIndex) {
        pageNum = (pageIndex ?? 0) + 1;
        return _getList();
      },
    );

    super.initState();

    WidgetsBinding.instance.addPostFrameCallback((timeStamp) async {
      SharedPreferences prefs = await SharedPreferences.getInstance();
      bool isAppInitRun = prefs.getBool("isAppInitRun") ?? true;

      // debugPrint("[DatagridExtender] isAppInitRun: ${isAppInitRun.toString()}");
      var futureWithTheLoop = () async {
        while (isAppInitRun) {
          isAppInitRun = prefs.getBool("isAppInitRun") ?? true;
          // debugPrint("[DatagridExtender] isAppInitRun: ${isAppInitRun.toString()}");
          await Future.delayed(const Duration(milliseconds: 10));
        }
      }();

      Future.wait([futureWithTheLoop]).whenComplete(() {
        if (!isAppInitRun) {
          isFirstLoad = true;
        }
      });
    });
  }
  //endregion

  //region Methods
  Future<List<Map<String, dynamic>>> _getList() async {
    List<Map<String, dynamic>>? lstData;

    List<String> lstSearchKey = [];
    List<String> lstSearchBy = [];

    String strSqlFilter = "";
    String strSqlSortBy = "";
    bool isRefreshData = false;

    debugPrint("_getList");
    debugPrint("isRefresh ${widget.controller.isRefresh}");
    debugPrint("isRefreshOnFilter ${widget.isRefreshOnFilter}");
    debugPrint("isFilterTriggerRefresh $isFilterTriggerRefresh");
    debugPrint(
        "lstSearchController.length ${lstSearchController.length.toString()}");
    debugPrint(
        "gridSelectedItem.length ${widget.controller._gridSelectedItem.length.toString()}");

    debugPrint("isFirstLoad $isFirstLoad");
    debugPrint("PageNum $pageNum");
    debugPrint("PageSize $pageSize");

    isRefreshData = widget.controller.isRefresh;

    if (isFirstLoad) {
      isFirstLoad = false;
    }

    if (lstSearchController.isNotEmpty) {
      debugPrint("_getList - create filter");

      for (int n = 0; n < lstSearchController.keys.length; n++) {
        lstSearchBy.add(lstSearchController.keys.elementAt(n));
        FlatEditTextController? flatText =
            lstSearchController[lstSearchController.keys.elementAt(n)];
        if (flatText != null) {
          lstSearchKey.add(flatText.text);
        }
      }
    }

    if (lstSearchBy.isNotEmpty &&
        lstSearchKey.isNotEmpty &&
        widget.isRefreshOnFilter) {
      for (int s = 0; s < lstSearchKey.length; s++) {
        if (lstSearchKey[s].isNotEmpty) {
          if (strSqlFilter.isNotEmpty) {
            strSqlFilter += " AND ";
          }
          strSqlFilter += "${lstSearchBy[s]} LIKE '%${lstSearchKey[s]}%'";
        }
      }
      // debugPrint(strSqlFilter);
    }

    if (strSortBy.isNotEmpty && widget.isRefreshOnFilter) {
      strSqlSortBy = "$strSortBy ${strSortDirection == "A" ? "ASC" : "DESC"}";
    }

    if (!isRefreshData) {
      if (widget.isRefreshOnFilter &&
          strSqlFilter.isNotEmpty &&
          isFilterTriggerRefresh) {
        isRefreshData = true;
        isFilterTriggerRefresh = false;
      }
    }

    if (isRefreshData) {
      if (!widget.autoGeneratedColumns) {
        if (widget.controller.isClear == true) {
          lstDEColumn.clear();
          widget.controller.isClear = false;
        }
        lstDEColumn = widget.deColumns!;
      }

      debugPrint("getFutureData");
      List lstT = await widget.futureData(
          pageNum, pageSize, strSqlFilter, strSqlSortBy) as List;
      // debugPrint("getFutureData - finish");

      if (lstT.isNotEmpty) {
        lstData = [];
        if (lstT[0] is Map<String, dynamic>) {
          for (int r = 0; r < lstT.length; r++) {
            Map<String, dynamic> map = lstT[r];
            lstData.add(map);
          }
        } else {
          lstData =
              lstT.map((e) => e.toMap()).cast<Map<String, dynamic>>().toList();
        }
      }

      if (lstData != null) {
        for (int r = 0; r < lstData.length; r++) {
          Map<String, dynamic> mapRow = lstData[r];
          if (!mapRow.containsKey("IsSelected")) {
            mapRow["IsSelected"] = false;
          }

          if (_selectedItemExists(mapRow) > -1) {
            mapRow["IsSelected"] = true;
          }

          lstData[r] = mapRow;
        }
      }

      widget.controller.gridItem = lstData ?? [];
    } else {
      lstData = widget.controller.gridItem;
    }

    // debugPrint("_getList - filter");
    if (lstSearchController.isNotEmpty) {
      // debugPrint(lstSearchKey.join("|"));
      if (lstSearchBy.isNotEmpty &&
          lstSearchKey.isNotEmpty &&
          !widget.isRefreshOnFilter) {
        for (int s = 0; s < lstSearchKey.length; s++) {
          if (lstData != null &&
              lstData.isNotEmpty &&
              lstSearchKey[s].isNotEmpty) {
            lstData = lstData.where((e) {
              // debugPrint("${e[lstSearchBy[s]].toString().toLowerCase()} is contain ${lstSearchKey[s]}");
              return e[lstSearchBy[s]]
                  .toString()
                  .toLowerCase()
                  .contains(lstSearchKey[s].toLowerCase());
            }).toList();
          }
        }
      }

      // debugPrint("_getList - sort");
      if (lstSearchBy.isNotEmpty &&
          strSortBy.isNotEmpty &&
          !widget.isRefreshOnFilter) {
        //debugPrint("$strSortBy $strSortDirection");
        lstData!.sort(
          (a, b) {
            if (strSortDirection == "A") {
              return a[strSortBy]
                  .toString()
                  .toLowerCase()
                  .compareTo(b[strSortBy].toString().toLowerCase());
            } else {
              return b[strSortBy]
                  .toString()
                  .toLowerCase()
                  .compareTo(a[strSortBy].toString().toLowerCase());
            }
          },
        );
      }
    }

    // if(widget.controller._isClear){
    //   widget.controller._isClear = false;
    //   lstData = [];
    // }

    // debugPrint("_getList - finish");

    if (widget.controller.isRefresh) {
      widget.controller.isRefresh = false;

      // debugPrint("_getList - lstSearchController.clear()");
      // lstSearchController.clear();
    }

    // if(isRefreshData) {
    //   if (!widget.autoGeneratedColumns) {
    //     if (widget.controller.isClear == true) {
    //       lstDEColumn.clear();
    //       widget.controller.isClear = false;
    //     }
    //     lstDEColumn = widget.deColumns!;
    //   }
    // }

    if (lstData != null) {
      for (int r = 0; r < lstData.length; r++) {
        Map<String, dynamic> mapRow = lstData[r];
        if (!mapRow.containsKey("IsSelected")) {
          mapRow["IsSelected"] = false;
          lstData[r] = mapRow;
        }
      }
    }

    widget.controller._gridShowItem = lstData ?? [];
    // debugPrint(lstData.toString());
    return Future.value(lstData);
  }

  void _generateColumnProperty(List<DEColumn> lstDEColumn) {
    // numericColumns.clear();
    // hoverColumns.clear();
    // mapColWidth.clear();
    // lstSearchController = {};

    // if (numericColumns.length != lstDEColumn.length) {
    //   numericColumns.clear();
    // }
    //
    // if (hoverColumns.length != lstDEColumn.length) {
    //   hoverColumns.clear();
    // }

    // if (mapColWidth.length != lstDEColumn.length) {
    //   mapColWidth.clear();
    // }

    if (lstDEColumn.isNotEmpty) {
      double totalColWidth = 0;

      for (int h = 0; h < lstDEColumn.length; h++) {
        DEColumn objHeader = lstDEColumn[h];
        // debugPrint("Generate ColumnProperty ${objHeader.columnName}");

        // debugPrint("add lstSearchController ");
        if (!lstSearchController.containsKey(objHeader.columnName)) {
          lstSearchController[objHeader.columnName] = FlatEditTextController();
        }

        // debugPrint("add numericColumns");
        if (!numericColumns.containsKey(objHeader.columnName)) {
          bool isNum = false;
          if (objHeader.columnType == DEColumnType.Numeric) {
            isNum = true;

            if (objHeader.columnFormat == DENumericFormat.Date ||
                objHeader.columnFormat == DENumericFormat.Time ||
                objHeader.columnFormat == DENumericFormat.Time2 ||
                objHeader.columnFormat == DENumericFormat.DateTime ||
                objHeader.columnFormat == DENumericFormat.Flag) {
              isNum = false;
            }
          }

          numericColumns[objHeader.columnName] = isNum;
        }

        // debugPrint("add hoverColumns");
        if (!hoverColumns.containsKey(objHeader.columnName)) {
          hoverColumns[objHeader.columnName] = false;
        }

        // debugPrint("add mapColWidth");
        if (objHeader.columnType == DEColumnType.DECheckbox) {
          mapColWidth[h] = 30;
        } else if (objHeader.columnType == DEColumnType.DEMoreMenu) {
          mapColWidth[h] = 30;
        } else {
          if (objHeader.columnWidth > 0) {
            mapColWidth[h] = objHeader.columnWidth;
          } else {
            mapColWidth[h] = -1;
          }
        }

        if (mapColWidth[h] != -1) {
          totalColWidth += mapColWidth[h] ?? 0;
        }
      }

      if (isEnableGridScroll && mapColWidth.containsValue(-1)) {
        // debugPrint("calculate mapColWidth -1");
        for (int c = 0; c < mapColWidth.length; c++) {
          if (mapColWidth[c] == -1) {
            mapColWidth[c] = gridWidth - totalColWidth;
          }
        }
      }
    }
  }

  void _saveSelectedItem(
      Map<String, dynamic> mapRowSelectedItem, bool chbValue) {
    Map<String, dynamic> mapCompare = {...mapRowSelectedItem};
    mapCompare["IsSelected"] = true;

    if (widget.controller._gridSelectedItem.isNotEmpty) {
      int intSelectedItem = _selectedItemExists(mapCompare);
      bool isSelectedItemExists = intSelectedItem > -1;

      if (isSelectedItemExists) {
        //NotEmpty-Exists-False
        if (!chbValue) {
          widget.controller._gridSelectedItem.removeAt(intSelectedItem);
        }
      } else {
        //NotEmpty-NotExists-True
        if (chbValue) {
          widget.controller._gridSelectedItem.add(mapCompare);
        }
      }
    } else {
      //Empty-True
      if (chbValue) {
        widget.controller._gridSelectedItem.add(mapCompare);
      }
    }
  }

  int _selectedItemExists(Map<String, dynamic> mapRowSelectedItem) {
    Map<String, dynamic> mapCompare = {...mapRowSelectedItem};
    mapCompare["IsSelected"] = true;
    int intSelectedItem = -1;

    if (widget.controller._gridSelectedItem.isNotEmpty) {
      for (int c = 0; c < widget.controller._gridSelectedItem.length; c++) {
        if (mapEquals(
            widget.controller._gridSelectedItem.elementAt(c), mapCompare)) {
          intSelectedItem = c;
          break;
        }
      }
    }

    return intSelectedItem;
  }
  //endregion

  @override
  Widget build(BuildContext context) {
    //debugPrint("gridWidth: " + gridWidth.toString());

    return LayoutBuilder(
      builder: (context, constraint) {
        // double columnWidth = 0;
        // for(int h = 0; h < lstDEColumn.length; h++){
        //   DEColumn objHeader = lstDEColumn[h];
        //   if(objHeader.columnWidth > 0){
        //     columnWidth += objHeader.columnWidth;
        //   }else{
        //     if(objHeader.columnType != DEColumnType.DECheckbox) {
        //       columnWidth = 0;
        //       break;
        //     }
        //   }
        // }

        gridWidth = widget.width ?? MediaQuery.of(context).size.width - 80;

        //double gridWidth = context.size!.width;
        // if(columnWidth > 0){
        //   gridWidth = columnWidth;
        // }

        // debugPrint("gridWidth ${gridWidth.toString()}");

        return Container(
          margin: const EdgeInsets.only(top: 5),
          child: SizedBox(width: gridWidth, child: widgetDERow()),
        );
      },
    );
  }

  Widget widgetDEHeader(List<DEColumn> lstDEColumn) {
    //COLUMNS
    List<Widget> columnCells = [];
    if (lstDEColumn.isNotEmpty) {
      // debugPrint("Generate DEHeader");
      for (int h = 0; h < lstDEColumn.length; h++) {
        DEColumn objHeader = lstDEColumn[h];

        String strHeaderText = objHeader.headerText;
        if (strHeaderText.isEmpty) {
          strHeaderText = objHeader.columnName;
        }
        strHeaderText = LabelDictionary.getLabelDictionary(strHeaderText);

        Widget cc = Container(
          color: GlobalStyle.gridColor, //gridHeaderColor,//cwh
          padding: const EdgeInsets.only(left: 2, top: 5, right: 5, bottom: 5),
          child: InkWell(
            hoverColor: Colors.transparent,
            onTap: () {
              setState(() {
                strSortDirection = strSortDirection == "A" ? "D" : "A";
                strSortBy = objHeader.columnName;
                // debugPrint("$strSortBy $strSortDirection");
              });
            },
            child: Row(
              children: [
                Expanded(
                  child: Text(
                    strHeaderText,
                    style: objHeader.headerStyle ??
                        TextStyle(
                            fontSize: GlobalStyle.fontSize,
                            color: GlobalStyle.gridHeaderTextColor,
                            fontWeight: FontWeight.w600),
                    textAlign: objHeader.columnAlign ??
                        (numericColumns[objHeader.columnName]
                            ? TextAlign.end
                            : TextAlign.start),
                  ),
                ),
                // Container(
                //   width: 20,
                //   height: 20,
                //   margin: const EdgeInsets.only(bottom: 0, left: 2, right: 2),
                //   child: Icon(Icons.arrow_drop_up, color: Colors.black,),
                // ),
              ],
            ),
          ),
        );

        if (objHeader.columnType == DEColumnType.DECheckbox) {
          cc = builderHeaderDECheckbox(objHeader);
        }

        if (!widget.controller.hideColumns.contains(h)) {
          columnCells.add(cc);
        }
      }
    }

    if (columnCells.isNotEmpty) {
      Widget headerContent = Row(
        mainAxisAlignment: MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.center,
        mainAxisSize: MainAxisSize.max,
        children: columnCells.mapIndexed((index, element) {
          Widget cellHeader = Container(
              width: mapColWidth[index] == -1
                  ? double.infinity
                  : mapColWidth[index],
              padding: const EdgeInsets.fromLTRB(5, 0, 5, 0),
              color: GlobalStyle.gridColor, //gridHeaderColor,//cwh
              // decoration: const BoxDecoration(
              //     border: Border(left: BorderSide(color: Colors.orange, width: 1))
              // ),
              child: element);

          if (mapColWidth[index] == -1) {
            return Expanded(
              flex: 1,
              child: cellHeader,
            );
          }

          return cellHeader;
        }).toList(),
      );

      // debugPrint("DEFilter - isEnableGridScroll ${isEnableGridScroll.toString()}");
      if (isEnableGridScroll) {
        headerContent = Scrollbar(
          controller: horizontalHeaderScrollController,
          thumbVisibility: false,
          trackVisibility: false,
          child: SingleChildScrollView(
            controller: horizontalHeaderScrollController,
            scrollDirection: Axis.horizontal,
            child: headerContent,
          ),
        );
      }

      return SizedBox(
        width: gridWidth,
        height: 30,
        child: Container(
          decoration: BoxDecoration(
              border: Border(
                  bottom: BorderSide(color: GlobalStyle.gridHeaderColor))),
          child: headerContent,
        ),
      );
    }

    return Container(
      padding: const EdgeInsets.fromLTRB(2, 5, 5, 5),
      height: 30,
      color: GlobalStyle.gridColor, //gridHeaderColor,
    );
  }

  Widget widgetDESubTotal(List<DEColumn> lstDEColumn) {
    //COLUMNS
    List<Widget> columnCells = [];
    // bool isSubTotalTextPlaced = false;

    if (lstDEColumn.isNotEmpty) {
      // debugPrint("Generate DEHeader");
      for (int h = 0; h < lstDEColumn.length; h++) {
        DEColumn objHeader = lstDEColumn[h];

        String strCellVal = "";
        if (numericColumns[objHeader.columnName]) {
          double dblVal = double.tryParse(
                  numericColumnSums[objHeader.columnName].toString()) ??
              0;
          switch (objHeader.columnFormat) {
            case DENumericFormat.Unit:
              {
                strCellVal = CommonMethod.NumericToStringFormat(
                    NumericType.Unit, dblVal);
                break;
              }
            case DENumericFormat.Amount:
              {
                strCellVal = CommonMethod.NumericToStringFormat(
                    NumericType.Amount, dblVal);
                break;
              }
            case DENumericFormat.Percent:
              {
                strCellVal = CommonMethod.NumericToStringFormat(
                    NumericType.Percent, dblVal);
                break;
              }
            case DENumericFormat.Price:
              {
                strCellVal = CommonMethod.NumericToStringFormat(
                    NumericType.Price, dblVal);
                break;
              }
            case DENumericFormat.Quantity:
              {
                strCellVal = CommonMethod.NumericToStringFormat(
                    NumericType.Quantity, dblVal);
                break;
              }
            case DENumericFormat.Rate:
              {
                strCellVal = CommonMethod.NumericToStringFormat(
                    NumericType.Rate, dblVal);
                break;
              }
            default:
              {
                break;
              }
          }
        }

        // if (!isSubTotalTextPlaced && objHeader.columnType != DEColumnType.DECheckbox) {
        //   strCellVal = "Sub Total";
        //   isSubTotalTextPlaced = true;
        // }

        if (h == 1) {
          strCellVal = "Sub Total";
        }

        Widget cc = Container(
          color: GlobalStyle.gridColor,
          padding: const EdgeInsets.only(left: 2, top: 5, right: 5, bottom: 5),
          child: Row(
            children: [
              Expanded(
                child: SelectableText(
                  strCellVal,
                  style: objHeader.headerStyle ??
                      TextStyle(
                          fontSize: GlobalStyle.fontSize,
                          color: GlobalStyle.gridHeaderTextColor,
                          fontWeight: FontWeight.w600),
                  textAlign: objHeader.columnAlign ??
                      (numericColumns[objHeader.columnName]
                          ? TextAlign.end
                          : TextAlign.start),
                ),
              ),
              // Container(
              //   width: 20,
              //   height: 20,
              //   margin: const EdgeInsets.only(bottom: 0, left: 2, right: 2),
              //   child: Icon(Icons.arrow_drop_up, color: Colors.black,),
              // ),
            ],
          ),
        );

        if (!widget.controller.hideColumns.contains(h)) {
          columnCells.add(cc);
        }
      }
    }

    if (columnCells.isNotEmpty) {
      Widget headerContent = Row(
        mainAxisAlignment: MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.center,
        mainAxisSize: MainAxisSize.max,
        children: columnCells.mapIndexed((index, element) {
          Widget cellHeader = Container(
              width: mapColWidth[index] == -1
                  ? double.infinity
                  : mapColWidth[index],
              padding: const EdgeInsets.fromLTRB(5, 0, 5, 0),
              color: GlobalStyle.gridColor, //gridHeaderColor,//cwh
              // decoration: const BoxDecoration(
              //     border: Border(left: BorderSide(color: Colors.orange, width: 1))
              // ),
              child: element);

          if (mapColWidth[index] == -1) {
            return Expanded(
              flex: 1,
              child: cellHeader,
            );
          }

          return cellHeader;
        }).toList(),
      );

      // debugPrint("DEFilter - isEnableGridScroll ${isEnableGridScroll.toString()}");
      if (isEnableGridScroll) {
        headerContent = Scrollbar(
          controller: horizontalSubTotalScrollController,
          thumbVisibility: false,
          trackVisibility: false,
          child: SingleChildScrollView(
            controller: horizontalSubTotalScrollController,
            scrollDirection: Axis.horizontal,
            child: headerContent,
          ),
        );
      }

      return SizedBox(
        width: gridWidth,
        height: 30,
        child: Container(
          decoration: BoxDecoration(
              border: Border(
                  bottom: BorderSide(color: GlobalStyle.gridHeaderColor))),
          child: headerContent,
        ),
      );
    }

    return Container(
      padding: const EdgeInsets.fromLTRB(2, 5, 5, 5),
      height: 30,
      color: GlobalStyle.gridColor, //gridHeaderColor,
    );
  }

  Widget widgetDEFilter(List<DEColumn> lstDEColumn) {
    //COLUMNS
    List<Widget> columnCells = [];
    if (lstDEColumn.isNotEmpty) {
      // debugPrint("Generate DEColumns");
      for (int h = 0; h < lstDEColumn.length; h++) {
        DEColumn objHeader = lstDEColumn[h];

        String strHeaderText = objHeader.headerText;
        if (strHeaderText.isEmpty) {
          strHeaderText = objHeader.columnName;
        }
        strHeaderText = LabelDictionary.getLabelDictionary(strHeaderText);

        Widget cc = Container(
          padding: const EdgeInsets.only(left: 2, top: 5, right: 5, bottom: 5),
          child: FlatEditText(
              controller: lstSearchController[objHeader.columnName]!,
              hintText: "Search $strHeaderText",
              onLostFocus: () {
                setState(() {
                  isFilterTriggerRefresh = true;
                  pageNum = 1;
                });
              }),
        );

        if (objHeader.columnType == DEColumnType.DECheckbox) {
          cc = Container(
            margin: const EdgeInsets.only(top: 4.5),
            alignment: Alignment.center,
            child: SizedBox(
              width: 30,
              height: 30,
              child: Container(),
            ),
          );
        }

        if (objHeader.columnType == DEColumnType.DEMoreMenu) {
          cc = Container(
            margin: const EdgeInsets.only(top: 4.5),
            alignment: Alignment.center,
            child: SizedBox(
              width: 30,
              height: 30,
              child: Container(),
            ),
          );
        }

        if (!widget.controller.hideColumns.contains(h)) {
          columnCells.add(cc);
        }
      }
    }

    if (columnCells.isNotEmpty) {
      Widget filterContent = Row(
        mainAxisAlignment: MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.center,
        mainAxisSize: MainAxisSize.max,
        children: columnCells.mapIndexed((index, element) {
          Widget cellHeader = Container(
              width: mapColWidth[index] == -1
                  ? double.infinity
                  : mapColWidth[index],
              padding: const EdgeInsets.fromLTRB(5, 0, 5, 0),
              // decoration: const BoxDecoration(
              //     border: Border(left: BorderSide(color: Colors.black, width: 1))
              // ),
              child: element);

          if (mapColWidth[index] == -1) {
            return Expanded(
              flex: 1,
              child: cellHeader,
            );
          }

          return cellHeader;
        }).toList(),
      );

      // debugPrint("DEFilter - isEnableGridScroll ${isEnableGridScroll.toString()}");
      if (isEnableGridScroll) {
        filterContent = Scrollbar(
          controller: horizontalFilterScrollController,
          thumbVisibility: false,
          trackVisibility: false,
          child: SingleChildScrollView(
            controller: horizontalFilterScrollController,
            scrollDirection: Axis.horizontal,
            child: filterContent,
          ),
        );
      }

      return SizedBox(
        width: gridWidth,
        height: 30,
        child: Container(
          decoration: BoxDecoration(
              border: Border(bottom: BorderSide(color: GlobalStyle.gridColor))),
          child: filterContent,
        ),
      );
    }

    return Container(
      padding: const EdgeInsets.fromLTRB(2, 5, 5, 5),
      height: 30,
      color: GlobalStyle.gridColor,
    );
  }

  Widget widgetDERow() {
    if (!widget.autoGeneratedColumns && lstDEColumn.isEmpty) {
      lstDEColumn = widget.deColumns!;
    }

    return FutureBuilder(
      future: _getList(),
      builder: (context, snapshot) {
        _generateColumnProperty(lstDEColumn);

        if (snapshot.connectionState == ConnectionState.done) {
          SchedulerBinding.instance.addPostFrameCallback((_) async {
            await Future.delayed(const Duration(milliseconds: 500));

            // checkboxHeaderValue = false;

            // if(widget.controller._gridShowItem.isNotEmpty){
            //   if(widget.controller._gridShowItem.firstWhereOrNull((el) => el["IsSelected"] == false) == null){
            //     debugPrint("Not Found IsSelected False");
            //     checkboxHeaderValue = true;
            //   }
            // }
            //
            // debugPrint("checkboxHeaderValue $checkboxHeaderValue");

            edtPage.text = (totalPage > 0 ? pageNum : 0).toString();
            edtPageSize.text = pageSize.toString();

            if (widget.onAfterRefresh != null) {
              widget.onAfterRefresh!();
            }
          });

          //CWH : jika auto generate tidak ada data tetap ada notif no data found
          // if(!widget.autoGeneratedColumns) {
          widgetDEBody = const Center(child: Text("No Data Found"));
          // }else{
          //   widgetDEBody = Container();
          // }

          if (snapshot.hasData) {
            horizontalBodyScrollController =
                horizontalGroupScrollController.addAndGet();
            ScrollController verticalBodyScrollController = ScrollController();

            List<Map<String, dynamic>> mapRows = snapshot.data ?? [];

            if (mapRows.isNotEmpty) {
              checkboxHeaderValue = true;

              if (mapRows.firstWhereOrNull((el) => el["IsSelected"] == false) !=
                  null) {
                checkboxHeaderValue = false;
              }

              // debugPrint("checkboxHeaderValue $checkboxHeaderValue");

              Map<String, dynamic> mapZero = mapRows[0];
              totalPage = mapZero["TotalPage"] ?? 0;
              totalRecord = mapZero["TotalRecord"] ?? 0;

              debugPrint(mapRows[0].keys.toString());
              debugPrint(mapZero.keys.toString());

              String strDecCol1 = mapZero["DecimalColumn"] ?? "";
              if (strDecCol1.isNotEmpty) {
                List<String> lstDecColTemp1 = strDecCol1.split(";");

                for (String strDecCol2 in lstDecColTemp1) {
                  if (strDecCol2.contains("|")) {
                    List<String> lstDecColTemp2 = strDecCol2.split("|");
                    lstDecimalColumn.add(lstDecColTemp2[0]);
                    numericColumnSums[lstDecColTemp2[0]] = double.tryParse(
                            lstDecColTemp2[1].replaceAll(",", ".")) ??
                        0;
                  } else {
                    lstDecimalColumn.add(strDecCol2);
                  }
                }
              }

              if (widget.onGenerateColumn != null) {
                List<String> lstColumnName = [];
                for (int k = 0; k < mapZero.keys.length; k++) {
                  lstColumnName.add(mapZero.keys.elementAt(k));
                }

                List<DEColumn> lstColumnBound =
                    widget.onGenerateColumn!(lstDEColumn, lstColumnName) ?? [];

                if (lstColumnBound.isNotEmpty) {
                  lstDEColumn.clear();
                  lstDEColumn.addAll(lstColumnBound);
                }
              }

              if (widget.autoGeneratedColumns) {
                lstDEColumn.clear();

                List<String> lstExclude = [
                  "PageNumber",
                  "PageSize",
                  "TotalPage",
                  "TotalRecord",
                  "IsSelected",
                  "DecimalColumn",
                  "ColumnName"
                ];

                String strColName = mapZero["ColumnName"] ?? "";

                if (strColName.isEmpty) {
                  strColName = mapZero.keys.join(";");
                }

                List<String> lstColumnName = strColName.split(";");

                for (int k = 0; k < lstColumnName.length; k++) {
                  String strColumnName = lstColumnName[k];

                  if (!lstExclude.contains(strColumnName)) {
                    DEColumn deColumn = DEColumn(
                      headerText: strColumnName,
                      columnName: strColumnName,
                      columnType: DEColumnType.String,
                      columnAlign: TextAlign.start,
                      columnWidth: 100,
                    );

                    if (lstDecimalColumn.isNotEmpty) {
                      if (lstDecimalColumn.contains(strColumnName)) {
                        deColumn.columnType = DEColumnType.Numeric;
                        deColumn.columnFormat = DENumericFormat.Amount;
                        deColumn.columnAlign = TextAlign.end;
                      }
                    }

                    if (widget.autoGeneratedColumnStyle != null) {
                      DEColumnStyle? deColumnStyle =
                          widget.autoGeneratedColumnStyle!.firstWhereOrNull(
                              (el) => el.columnName == strColumnName);

                      if (deColumnStyle != null) {
                        deColumn.columnType = deColumnStyle.columnType;
                        deColumn.columnFormat = deColumnStyle.columnFormat;

                        if (deColumnStyle.columnWidth > 0) {
                          deColumn.columnWidth = deColumnStyle.columnWidth;
                        }

                        if (deColumnStyle.columnType == DEColumnType.Numeric) {
                          deColumn.columnAlign = TextAlign.end;

                          if (deColumn.columnFormat == DENumericFormat.Date ||
                              deColumn.columnFormat == DENumericFormat.Time ||
                              deColumn.columnFormat == DENumericFormat.Time2 ||
                              deColumn.columnFormat ==
                                  DENumericFormat.DateTime ||
                              deColumn.columnFormat == DENumericFormat.Flag) {
                            deColumn.columnAlign = TextAlign.start;
                          }
                        }
                      }
                    }

                    lstDEColumn.add(deColumn);
                  }
                }
              }

              _generateColumnProperty(lstDEColumn);

              // debugPrint("Generate DERows");
              List<Widget> tableRows = [];

              for (int r = 0; r < mapRows.length; r++) {
                Map<String, dynamic> mapRow = mapRows[r];

                Color rowColor = GlobalStyle.gridItemColor;

                if (r % 2 == 0) {
                  rowColor = GlobalStyle.gridItemColor;
                }

                //debugPrint(numericColumns);

                List<Widget> rowCells = [];
                for (int h = 0; h < lstDEColumn.length; h++) {
                  DEColumn objHeader = lstDEColumn[h];
                  Widget rc = Container();
                  switch (objHeader.columnType) {
                    case DEColumnType.String:
                      {
                        rc = builderDEColumnString(objHeader, mapRow);
                        break;
                      }
                    case DEColumnType.Numeric:
                      {
                        rc = builderDEColumnNumeric(objHeader, mapRow);
                        break;
                      }
                    case DEColumnType.DECheckbox:
                      {
                        rc = builderDEColumnCheckbox(r, objHeader, mapRow);
                        break;
                      }
                    case DEColumnType.DEMoreMenu:
                      {
                        rc = builderDEColumnMoreMenu(objHeader.popupMenuItems);
                        break;
                      }
                    case DEColumnType.Widget:
                      {
                        if (objHeader.cellBuilder != null) {
                          rc = objHeader.cellBuilder!(r, mapRow);
                        }
                        break;
                      }
                    default:
                      break;
                  }

                  if (!widget.controller.hideColumns.contains(h)) {
                    rowCells.add(rc);
                  }
                }

                var tr = Container(
                  decoration: BoxDecoration(
                    color: rowColor,
                    border: const Border(
                        bottom: BorderSide(color: Colors.black26, width: 0.5)),
                  ),
                  padding: widget.height != null
                      ? const EdgeInsets.only(right: 20)
                      : null,
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.start,
                    crossAxisAlignment: CrossAxisAlignment.center,
                    mainAxisSize: MainAxisSize.max,
                    children: rowCells.mapIndexed((index, element) {
                      //debugPrint("$index: ${mapColWidth[index]}");
                      Widget cellRow = Container(
                          width: mapColWidth[index] == -1
                              ? double.infinity
                              : mapColWidth[index],
                          padding: const EdgeInsets.fromLTRB(5, 0, 5, 0),
                          // decoration: const BoxDecoration(
                          //     border: Border(left: BorderSide(color: Colors.black, width: 1))
                          // ),
                          child: element);

                      if (mapColWidth[index] == -1) {
                        return Expanded(
                          flex: 1,
                          child: cellRow,
                        );
                      }

                      return cellRow;
                    }).toList(),
                  ),
                );

                // var tr = TableRow(
                //   decoration: BoxDecoration(
                //     color: rowColor,
                //   ),
                //   children: rowCells,
                // );

                tableRows.add(tr);
              }

              if (tableRows.isNotEmpty) {
                Widget bodyContent = Column(
                  children: tableRows,
                );

                // debugPrint("DEBody - isEnableGridScroll ${isEnableGridScroll.toString()}");
                if (isEnableGridScroll) {
                  bodyContent = AdaptiveScrollbar(
                    controller: verticalBodyScrollController,
                    width: 10,
                    scrollToClickDelta: 75,
                    scrollToClickFirstDelay: 200,
                    scrollToClickOtherDelay: 50,
                    sliderDecoration: const BoxDecoration(
                        color: Color(0xffc1c1c1),
                        borderRadius: BorderRadius.all(Radius.circular(5))),
                    sliderActiveDecoration: const BoxDecoration(
                        color: Color(0xffa8a8a8),
                        borderRadius: BorderRadius.all(Radius.circular(5))),
                    underDecoration: const BoxDecoration(
                        shape: BoxShape.rectangle, color: Color(0xfff1f1f1)),
                    child: AdaptiveScrollbar(
                      // underSpacing: EdgeInsets.only(bottom: (!verticalScroll.hasClients ||
                      //     verticalScroll.position.maxScrollExtent == 0) ? adaptiveScrollWidth : 0),
                      underSpacing: const EdgeInsets.only(bottom: 10),
                      controller: horizontalBodyScrollController,
                      width: 10,
                      position: ScrollbarPosition.bottom,
                      sliderDecoration: const BoxDecoration(
                          color: Color(0xffc1c1c1),
                          borderRadius: BorderRadius.all(Radius.circular(5))),
                      sliderActiveDecoration: const BoxDecoration(
                          color: Color(0xffa8a8a8),
                          borderRadius: BorderRadius.all(Radius.circular(5))),
                      underDecoration: const BoxDecoration(
                          shape: BoxShape.rectangle, color: Color(0xfff1f1f1)),
                      child: SingleChildScrollView(
                        controller: verticalBodyScrollController,
                        child: SingleChildScrollView(
                          controller: horizontalBodyScrollController,
                          scrollDirection: Axis.horizontal,
                          child: bodyContent,
                        ),
                      ),
                    ),
                  );
                }

                widgetDEBody = bodyContent;
              }
            }
          } else {
            if (widget.autoGeneratedColumns) {
              lstDEColumn.clear();
            }
          }

          // widgetDEBody = SizedBox(
          //   key: UniqueKey(),
          //   width: gridWidth,
          //   height: widget.height, // ?? double.infinity,
          //   child: widgetDEBody,
          // );

          widgetDEBody = Container(
            key: UniqueKey(),
            child: ConstrainedBox(
              constraints: BoxConstraints(
                maxWidth: gridWidth,
                minWidth: 0,
                minHeight: 50,
                maxHeight: widget.height ?? double.infinity,
              ),
              // width: gridWidth,
              // height: widget.height,
              child: widgetDEBody,
            ),
          );
        }

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisAlignment: MainAxisAlignment.start,
          mainAxisSize: MainAxisSize.max,
          children: [
            widgetDEToolbar(),
            Visibility(
              visible: isAdvanceFilterContentVisible,
              child: widgetDEAdvanceFilter(),
            ),
            Visibility(
              visible: isContentVisible,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.start,
                mainAxisSize: MainAxisSize.max,
                children: [
                  widgetDEHeader(lstDEColumn),
                  Visibility(
                    visible: isFilterContentVisible,
                    child: widgetDEFilter(lstDEColumn),
                  ),
                  AnimatedSwitcher(
                    duration: const Duration(milliseconds: 500),
                    child: widgetDEBody,
                  ),
                  Visibility(
                    visible: widget.isSubTotalVisible ?? false,
                    child: widgetDESubTotal(lstDEColumn),
                  ),
                  widgetDEFooter(lstDEColumn),
                ],
              ),
            ),
          ],
        );
      },
    );
  }

  Widget widgetDEToolbar() {
    return Container(
      width: double.infinity,
      height: 30,
      padding: const EdgeInsets.fromLTRB(10, 0, 10, 0),
      decoration: BoxDecoration(
        color: GlobalStyle.gridHeaderColor, //gridColor,
        border: Border(
          top: BorderSide(color: GlobalStyle.gridBorderColor, width: 1),
          bottom: BorderSide(color: GlobalStyle.gridBorderColor, width: 1),
        ),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        mainAxisAlignment: MainAxisAlignment.start,
        mainAxisSize: MainAxisSize.max,
        children: [
          // IconButtonExtender(
          //   onPressed: () {
          //     setState(() {
          //       isContentVisible = !isContentVisible;
          //     });
          //   },
          //   icon: isContentVisible ? Icons.keyboard_arrow_up : Icons.keyboard_arrow_right,
          // ),

          Container(
            padding: const EdgeInsets.only(right: 10),
            child: Text(
              widget.title ?? "",
              style: TextStyle(
                  fontSize: GlobalStyle.fontSize,
                  color: GlobalStyle.gridFontColor),
            ),
          ),
          Container(
            padding: const EdgeInsets.only(right: 5),
            child: IconButtonExtender(
              isVisible: widget.isAddLineVisible,
              isEnable: widget.isAddLineEnable,
              onPressed: () {
                if (widget.onAddLine != null) {
                  widget.onAddLine!();
                }
              },
              color: Colors.black,
              icon: Icons.add,
              iconLabel: widget.addLineLabel,
              tooltipText: widget.addLineLabel,
            ),
          ),
          IconButtonExtender(
            isVisible: widget.isDeleteLineVisible,
            isEnable: widget.isDeleteLineEnable,
            onPressed: () {
              if (widget.onDeleteLine != null) {
                widget.onDeleteLine!();
              }
            },
            color: Colors.black,
            icon: Icons.delete,
            iconLabel: widget.deleteLineLabel,
            tooltipText: widget.deleteLineLabel,
          ),

          Expanded(
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.center,
              mainAxisAlignment: MainAxisAlignment.end,
              mainAxisSize: MainAxisSize.max,
              children: [
                IconButtonExtender(
                  isVisible: widget.isAdvanceFilterVisible,
                  isEnable: widget.isAdvanceFilterEnable,
                  onPressed: () {
                    setState(() {
                      isAdvanceFilterContentVisible =
                          !isAdvanceFilterContentVisible;
                    });
                  },
                  iconImagePath: "assets/icons/advance-filter.png",
                  color: isAdvanceFilterContentVisible
                      ? GlobalStyle.primaryColor
                      : Colors.black,
                  tooltipText: "Advance filter",
                ),
                IconButtonExtender(
                  isVisible: widget.isRefreshVisible,
                  isEnable: widget.isRefreshEnable,
                  onPressed: () {
                    if (widget.onBeforeRefresh != null) {
                      widget.onBeforeRefresh!();
                    }
                    setState(() {
                      widget.controller.isRefresh = true;
                    });
                  },
                  icon: Icons.refresh,
                  // iconImagePath: "assets/icons/refresh.png",
                  tooltipText: "Refresh",
                  color: Colors.black,
                ),
                IconButtonExtender(
                  isVisible: widget.isFilterVisible,
                  isEnable: widget.isFilterEnable,
                  onPressed: () {
                    setState(() {
                      isFilterContentVisible = !isFilterContentVisible;
                    });
                  },
                  icon: Icons.filter_alt,
                  color: isFilterContentVisible
                      ? GlobalStyle.primaryColor
                      : Colors.black,
                  tooltipText: "Filter",
                ),
                widgetDEToolbarMoreMenu(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget widgetDEToolbarMoreMenu() {
    if (widget.isMoreMenuVisible && widget.popupMenuItems != null) {
      return HoverExtender(
        builder: (isHovered) {
          return PopupMenuButton(
            iconColor: isHovered ? GlobalStyle.primaryColor : Colors.black,
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints(),
            itemBuilder: (context) {
              return widget.popupMenuItems!.map((e) => e).toList();
            },
          );
        },
      );
    }
    return Container();
  }

  Widget widgetDEFooter(List<DEColumn> lstDEColumn) {
    // edtPage.text = (totalPage > 0 ? pageNum : 0).toString();
    // edtPageSize.text = pageSize.toString();

    //COLUMNS
    List<Widget> columnCells = [];
    if (lstDEColumn.isNotEmpty) {
      // debugPrint("Generate DEColumns");
      for (int h = 0; h < lstDEColumn.length; h++) {
        DEColumn objHeader = lstDEColumn[h];

        String strHeaderText = objHeader.headerText;
        if (strHeaderText.isEmpty) {
          strHeaderText = objHeader.columnName;
        }
        strHeaderText = LabelDictionary.getLabelDictionary(strHeaderText);

        Widget cc = Container(
          padding: const EdgeInsets.only(left: 2, top: 5, right: 5, bottom: 5),
          child: FlatEditText(
              controller: lstSearchController[objHeader.columnName]!,
              hintText: "Search $strHeaderText",
              onLostFocus: () {
                setState(() {
                  isFilterTriggerRefresh = true;
                  pageNum = 1;
                });
              }),
        );

        if (objHeader.columnType == DEColumnType.DECheckbox) {
          cc = Container(
            margin: const EdgeInsets.only(top: 4.5),
            alignment: Alignment.center,
            child: SizedBox(
              width: 30,
              height: 30,
              child: Container(),
            ),
          );
        }

        if (objHeader.columnType == DEColumnType.DEMoreMenu) {
          cc = Container(
            margin: const EdgeInsets.only(top: 4.5),
            alignment: Alignment.center,
            child: SizedBox(
              width: 30,
              height: 30,
              child: Container(),
            ),
          );
        }

        if (!widget.controller.hideColumns.contains(h)) {
          columnCells.add(cc);
        }
      }
    }

    if (columnCells.isNotEmpty) {
      Widget filterContent = Row(
        mainAxisAlignment: MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.center,
        mainAxisSize: MainAxisSize.max,
        children: columnCells.mapIndexed((index, element) {
          Widget cellHeader = Container(
              width: mapColWidth[index] == -1
                  ? double.infinity
                  : mapColWidth[index],
              padding: const EdgeInsets.fromLTRB(5, 0, 5, 0),
              // decoration: const BoxDecoration(
              //     border: Border(left: BorderSide(color: Colors.black, width: 1))
              // ),
              child: element);

          if (mapColWidth[index] == -1) {
            return Expanded(
              flex: 1,
              child: cellHeader,
            );
          }

          return cellHeader;
        }).toList(),
      );
    }

    if (widget.showPaging) {
      return Container(
        width: double.infinity,
        height: 30,
        padding: const EdgeInsets.fromLTRB(10, 0, 10, 0),
        decoration: BoxDecoration(
          color: GlobalStyle.gridHeaderColor,
          border: Border(
            top: BorderSide(color: GlobalStyle.gridBorderColor, width: 1),
            bottom: BorderSide(color: GlobalStyle.gridBorderColor, width: 1),
          ),
        ),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.center,
          mainAxisAlignment: MainAxisAlignment.start,
          mainAxisSize: MainAxisSize.max,
          children: [
            Text(
              "Page ",
              style: TextStyle(
                  fontSize: GlobalStyle.fontSize,
                  color: GlobalStyle.gridFontColor),
            ),
            EditText(
              controller: edtPage,
              textMode: TextInputType.number,
              width: 50,
              onLostFocus: () {
                setState(() {
                  int pn = int.parse(edtPage.text);

                  if (pn < 1) {
                    pn = 1;
                  }

                  pageNum = pn;
                  widget.controller.isRefresh = true;
                });
              },
            ),
            Text(
              " of $totalPage",
              style: TextStyle(
                  fontSize: GlobalStyle.fontSize,
                  color: GlobalStyle.gridFontColor),
            ),
            const SizedBox(
              width: 30,
            ),
            // const VerticalDivider(color: Colors.grey,),
            Container(
              margin: const EdgeInsets.only(left: 5),
              child: Text(
                "Row ",
                style: TextStyle(
                    fontSize: GlobalStyle.fontSize,
                    color: GlobalStyle.gridFontColor),
              ),
            ),
            EditText(
              controller: edtPageSize,
              textMode: TextInputType.number,
              width: 50,
              onLostFocus: () {
                setState(() {
                  int ps = int.parse(edtPageSize.text);

                  if (ps < 1) {
                    ps = 1;
                  }

                  pageNum = 1;
                  pageSize = ps;
                  widget.controller.isRefresh = true;
                });
              },
            ),
            const SizedBox(
              width: 30,
            ),
            // const VerticalDivider(color: Colors.grey,),
            Container(
              margin: const EdgeInsets.only(left: 5),
              child: Text(
                "Total ${NumberFormat("#${AppConfig.thousandSeparator}##0", "en_US").format(totalRecord)} Record(s)",
                style: TextStyle(
                    fontSize: GlobalStyle.fontSize,
                    color: GlobalStyle.gridFontColor,
                    fontWeight: FontWeight.bold),
              ),
            ),
            Expanded(
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.center,
                mainAxisAlignment: MainAxisAlignment.end,
                mainAxisSize: MainAxisSize.max,
                children: [
                  IconButtonExtender(
                    onPressed: () {
                      if (pageNum > 1) {
                        setState(() {
                          pageNum = 1;
                          widget.controller.isRefresh = true;
                        });
                      }
                    },
                    icon: Icons.first_page,
                    tooltipText: "First",
                  ),
                  IconButtonExtender(
                    onPressed: () {
                      if (pageNum > 1) {
                        setState(() {
                          pageNum -= 1;
                          widget.controller.isRefresh = true;
                        });
                      }
                    },
                    icon: Icons.navigate_before,
                    tooltipText: "Previous",
                  ),
                  IconButtonExtender(
                    onPressed: () {
                      if (pageNum < totalPage) {
                        setState(() {
                          pageNum += 1;
                          widget.controller.isRefresh = true;
                        });
                      }
                    },
                    icon: Icons.navigate_next,
                    tooltipText: "Next",
                  ),
                  IconButtonExtender(
                    onPressed: () {
                      if (pageNum < totalPage) {
                        setState(() {
                          pageNum = totalPage;
                          widget.controller.isRefresh = true;
                        });
                      }
                    },
                    icon: Icons.last_page,
                    tooltipText: "Last",
                  ),
                ],
              ),
            ),
          ],
        ),
      );
    } else {
      return Container();
    }
  }

  Widget widgetDEAdvanceFilter() {
    Widget filterContent = const Text("No advance filter");

    if (widget.filterBuilder != null) {
      filterContent = widget.filterBuilder!(context)!;
    }

    return Container(
      width: double.infinity,
      height: 500,
      padding: const EdgeInsets.fromLTRB(0, 0, 10, 0),
      decoration: BoxDecoration(
        color: Colors.white,
        border: Border.all(color: Colors.black26, width: 0.5),
      ),
      child: Scrollbar(
        controller: verticalAdvancedFilterScrollController,
        thumbVisibility: true,
        trackVisibility: true,
        child: SingleChildScrollView(
            controller: verticalAdvancedFilterScrollController,
            child: Container(
              padding: const EdgeInsets.all(10),
              child: filterContent,
            )),
      ),
    );
  }

  Widget builderDEColumnNumeric(DEColumn objHeader, dynamic map) {
    String strCellVal = "";
    var alignment = Alignment.centerRight;

    double dblVal = double.tryParse(map[objHeader.columnName].toString()) ?? 0;
    switch (objHeader.columnFormat) {
      case DENumericFormat.Date:
        {
          strCellVal = CommonMethod.NumericToDateString(dblVal);
          alignment = Alignment.centerLeft;
          break;
        }
      case DENumericFormat.Time:
        {
          strCellVal = CommonMethod.NumericToTimeString(dblVal);
          alignment = Alignment.centerLeft;
          break;
        }
      case DENumericFormat.Time2:
        {
          if (dblVal == 0) {
            strCellVal = "00:00:00";
          } else {
            strCellVal =
                CommonMethod.NumericToTimeString(dblVal, showSecond: true);
          }

          alignment = Alignment.centerLeft;
          break;
        }
      case DENumericFormat.DateTime:
        {
          strCellVal = CommonMethod.NumericToDateTimeString(dblVal);
          alignment = Alignment.centerLeft;
          break;
        }
      case DENumericFormat.Unit:
        {
          strCellVal =
              CommonMethod.NumericToStringFormat(NumericType.Unit, dblVal);
          break;
        }
      case DENumericFormat.Amount:
        {
          strCellVal =
              CommonMethod.NumericToStringFormat(NumericType.Amount, dblVal);
          break;
        }
      case DENumericFormat.Percent:
        {
          strCellVal =
              CommonMethod.NumericToStringFormat(NumericType.Percent, dblVal);
          break;
        }
      case DENumericFormat.Price:
        {
          strCellVal =
              CommonMethod.NumericToStringFormat(NumericType.Price, dblVal);
          break;
        }
      case DENumericFormat.Quantity:
        {
          strCellVal =
              CommonMethod.NumericToStringFormat(NumericType.Quantity, dblVal);
          break;
        }
      case DENumericFormat.Rate:
        {
          strCellVal =
              CommonMethod.NumericToStringFormat(NumericType.Rate, dblVal);
          break;
        }
      default:
        {
          break;
        }
    }

    //debugPrint(objHeader.columnName + ": " + strCellVal);

    var padding = const EdgeInsets.only(left: 2, top: 5, right: 5, bottom: 5);

    if (alignment == Alignment.centerLeft) {
      padding = const EdgeInsets.only(left: 5, top: 5, right: 2, bottom: 5);
    }
    return InkWell(
      onTap: () {
        if (objHeader.onSelected != null) {
          objHeader.onSelected!(map);
        } else {
          if (widget.onSelectedRow != null) {
            widget.onSelectedRow!(map);
          }
        }
      },
      child: Container(
        padding: padding,
        alignment: alignment,
        child: SelectableText(
          strCellVal,
          style: TextStyle(
            fontSize: GlobalStyle.fontSize,
            decoration: objHeader.onSelected != null
                ? TextDecoration.underline
                : TextDecoration.none,
          ),
        ),
      ),
    );
  }

  Widget builderDEColumnString(DEColumn objHeader, dynamic map) {
    String strCellVal = map[objHeader.columnName].toString();
    // debugPrint("${objHeader.columnName}: $strCellVal");

    return InkWell(
      onTap: () {
        if (objHeader.onSelected != null) {
          objHeader.onSelected!(map);
        } else {
          if (widget.onSelectedRow != null) {
            widget.onSelectedRow!(map);
          }
        }
      },
      child: Container(
        padding: const EdgeInsets.only(left: 2, top: 5, right: 5, bottom: 5),
        child: Text(
          strCellVal,
          textAlign: objHeader.columnAlign ?? TextAlign.start,
          style: TextStyle(
            fontSize: GlobalStyle.fontSize,
            decoration: objHeader.onSelected != null
                ? TextDecoration.underline
                : TextDecoration.none,
          ),
        ),
      ),
    );
  }

  Widget builderDEColumnCheckbox(int r, DEColumn objHeader, dynamic map) {
    // debugPrint("builderDEColumnCheckbox");
    // debugPrint("IsSelected: ${map["IsSelected"]}");

    return Container(
      margin: const EdgeInsets.only(top: 4.5),
      alignment: Alignment.center,
      child: SizedBox(
        width: 16,
        height: 16,
        child: Container(
          decoration: const BoxDecoration(color: Colors.white),
          child: Theme(
            data: ThemeData(
              primarySwatch: GlobalStyle.primaryMaterialColor,
              unselectedWidgetColor: GlobalStyle.primaryMaterialColor,
              disabledColor: GlobalStyle.disableMaterialColor,
            ),
            child: Checkbox(
                value: map["IsSelected"],
                activeColor: GlobalStyle.primaryColor,
                onChanged: (value) {
                  bool checkboxValue = value ?? false;

                  // debugPrint("IsSelected: $value");
                  // debugPrint("selectedAll: $selectedAll");
                  // Map<String, dynamic> gridItemFalse = widget.controller.gridItem.firstWhere((element) => element["IsSelected"] == false);
                  // chbHeaderIsSelected = !widget.controller._gridShowItem.firstWhere((element) => element["IsSelected"] == false).isNotEmpty;

                  if (map.keys.contains("IsSelected")) {
                    map["IsSelected"] = checkboxValue;
                    widget.controller._gridShowItem[r] = map;
                  }

                  _saveSelectedItem(map, checkboxValue);

                  int s = widget.controller.gridItem.indexOf(map);
                  Map<String, dynamic> mapRow = widget.controller.gridItem[s];
                  if (mapRow.containsKey("IsSelected")) {
                    mapRow["IsSelected"] = value;
                    widget.controller.gridItem[r] = mapRow;
                  }

                  // debugPrint("Checkbox onrow change - checkboxHeaderValue");
                  checkboxHeaderValue = !(widget.controller._gridShowItem
                          .firstWhereOrNull(
                              (el) => el["IsSelected"] == false) !=
                      null);

                  setState(() {
                    //trigger change state
                  });

                  if (objHeader.onSelected != null) {
                    // debugPrint("objHeader.onSelected");;
                    map["IsSelectedAll"] = checkboxHeaderValue;
                    objHeader.onSelected!(map);
                  }
                }),
          ),
        ),
      ),
    );
  }

  Widget builderHeaderDECheckbox(DEColumn objHeader) {
    return Container(
      margin: const EdgeInsets.only(top: 4.5),
      alignment: Alignment.center,
      child: SizedBox(
        width: 16,
        height: 16,
        child: Container(
          decoration: const BoxDecoration(color: Colors.white),
          child: Theme(
            data: ThemeData(
              primarySwatch: GlobalStyle.primaryMaterialColor,
              unselectedWidgetColor: GlobalStyle.primaryMaterialColor,
              disabledColor: GlobalStyle.disableMaterialColor,
            ),
            child: Checkbox(
                value: checkboxHeaderValue,
                activeColor: GlobalStyle.primaryColor,
                onChanged: (value) {
                  checkboxHeaderValue = value ?? false;

                  // debugPrint("gridItem length ${widget.controller.gridItem.length}");
                  if (widget.controller._gridShowItem.isNotEmpty) {
                    for (int q = 0;
                        q < widget.controller._gridShowItem.length;
                        q++) {
                      Map<String, dynamic> mapRowShowItem =
                          widget.controller._gridShowItem[q];
                      if (mapRowShowItem.containsKey("IsSelected")) {
                        mapRowShowItem["IsSelected"] = checkboxHeaderValue;
                        widget.controller._gridShowItem[q] = mapRowShowItem;
                      }

                      _saveSelectedItem(mapRowShowItem, checkboxHeaderValue);

                      int r =
                          widget.controller.gridItem.indexOf(mapRowShowItem);
                      Map<String, dynamic> mapRow =
                          widget.controller.gridItem[r];
                      if (mapRow.containsKey("IsSelected")) {
                        mapRow["IsSelected"] = checkboxHeaderValue;
                        widget.controller.gridItem[r] = mapRow;
                      }
                    }
                  }

                  // debugPrint("[All] gridSelectedItem.length: ${widget.controller._gridSelectedItem.length.toString()}");

                  setState(() {
                    //trigger change state
                  });

                  if (objHeader.onSelected != null) {
                    // debugPrint("objHeader.onSelected");
                    Map<String, dynamic> map = {};
                    map["IsSelectedAll"] = checkboxHeaderValue;
                    objHeader.onSelected!(map);
                  }
                }),
          ),
        ),
      ),
    );
  }

  Widget builderDEColumnMoreMenu(List<PopupMenuItem>? popupMenuItems) {
    //debugPrint("builderDEColumnMoreMenu");

    Widget popMenu = Container();

    if (popupMenuItems != null) {
      popMenu = Container(
        decoration: const BoxDecoration(color: Colors.white),
        child: Theme(
          data: ThemeData(
            primarySwatch: GlobalStyle.primaryMaterialColor,
            unselectedWidgetColor: GlobalStyle.primaryMaterialColor,
            disabledColor: GlobalStyle.disableMaterialColor,
          ),
          child: HoverExtender(
            builder: (isHovered) {
              return PopupMenuButton(
                iconColor: isHovered ? GlobalStyle.primaryColor : Colors.black,
                padding: EdgeInsets.zero,
                constraints: const BoxConstraints(),
                itemBuilder: (context) {
                  return popupMenuItems.map((e) => e).toList();
                },
              );
            },
          ),
        ),
      );
    }

    return Container(
      //margin: const EdgeInsets.only(top: 4.5),
      alignment: Alignment.center,
      child: SizedBox(width: 30, height: 30, child: popMenu),
    );
  }
}
//endregion
